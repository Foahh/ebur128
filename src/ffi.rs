/* automatically generated by rust-bindgen */

pub const EBUR128_VERSION_MAJOR: u32 = 1;
pub const EBUR128_VERSION_MINOR: u32 = 2;
pub const EBUR128_VERSION_PATCH: u32 = 4;
#[doc = "< unused channel (for example LFE channel)"]
pub const channel_EBUR128_UNUSED: channel = 0;
pub const channel_EBUR128_LEFT: channel = 1;
#[doc = "< itu M+030"]
pub const channel_EBUR128_Mp030: channel = 1;
pub const channel_EBUR128_RIGHT: channel = 2;
#[doc = "< itu M-030"]
pub const channel_EBUR128_Mm030: channel = 2;
pub const channel_EBUR128_CENTER: channel = 3;
#[doc = "< itu M+000"]
pub const channel_EBUR128_Mp000: channel = 3;
pub const channel_EBUR128_LEFT_SURROUND: channel = 4;
#[doc = "< itu M+110"]
pub const channel_EBUR128_Mp110: channel = 4;
pub const channel_EBUR128_RIGHT_SURROUND: channel = 5;
#[doc = "< itu M-110"]
pub const channel_EBUR128_Mm110: channel = 5;
#[doc = "< a channel that is counted twice"]
pub const channel_EBUR128_DUAL_MONO: channel = 6;
#[doc = "< itu M+SC"]
pub const channel_EBUR128_MpSC: channel = 7;
#[doc = "< itu M-SC"]
pub const channel_EBUR128_MmSC: channel = 8;
#[doc = "< itu M+060"]
pub const channel_EBUR128_Mp060: channel = 9;
#[doc = "< itu M-060"]
pub const channel_EBUR128_Mm060: channel = 10;
#[doc = "< itu M+090"]
pub const channel_EBUR128_Mp090: channel = 11;
#[doc = "< itu M-090"]
pub const channel_EBUR128_Mm090: channel = 12;
#[doc = "< itu M+135"]
pub const channel_EBUR128_Mp135: channel = 13;
#[doc = "< itu M-135"]
pub const channel_EBUR128_Mm135: channel = 14;
#[doc = "< itu M+180"]
pub const channel_EBUR128_Mp180: channel = 15;
#[doc = "< itu U+000"]
pub const channel_EBUR128_Up000: channel = 16;
#[doc = "< itu U+030"]
pub const channel_EBUR128_Up030: channel = 17;
#[doc = "< itu U-030"]
pub const channel_EBUR128_Um030: channel = 18;
#[doc = "< itu U+045"]
pub const channel_EBUR128_Up045: channel = 19;
#[doc = "< itu U-030"]
pub const channel_EBUR128_Um045: channel = 20;
#[doc = "< itu U+090"]
pub const channel_EBUR128_Up090: channel = 21;
#[doc = "< itu U-090"]
pub const channel_EBUR128_Um090: channel = 22;
#[doc = "< itu U+110"]
pub const channel_EBUR128_Up110: channel = 23;
#[doc = "< itu U-110"]
pub const channel_EBUR128_Um110: channel = 24;
#[doc = "< itu U+135"]
pub const channel_EBUR128_Up135: channel = 25;
#[doc = "< itu U-135"]
pub const channel_EBUR128_Um135: channel = 26;
#[doc = "< itu U+180"]
pub const channel_EBUR128_Up180: channel = 27;
#[doc = "< itu T+000"]
pub const channel_EBUR128_Tp000: channel = 28;
#[doc = "< itu B+000"]
pub const channel_EBUR128_Bp000: channel = 29;
#[doc = "< itu B+045"]
pub const channel_EBUR128_Bp045: channel = 30;
#[doc = "< itu B-045"]
pub const channel_EBUR128_Bm045: channel = 31;
#[doc = " \\enum channel"]
#[doc = "  Use these values when setting the channel map with ebur128_set_channel()."]
#[doc = "  See definitions in ITU R-REC-BS 1770-4"]
pub type channel = u32;
pub const error_EBUR128_SUCCESS: error = 0;
pub const error_EBUR128_ERROR_NOMEM: error = 1;
pub const error_EBUR128_ERROR_INVALID_MODE: error = 2;
pub const error_EBUR128_ERROR_INVALID_CHANNEL_INDEX: error = 3;
pub const error_EBUR128_ERROR_NO_CHANGE: error = 4;
#[doc = " \\enum error"]
#[doc = "  Error return values."]
pub type error = u32;
#[doc = " can call ebur128_loudness_momentary"]
pub const mode_EBUR128_MODE_M: mode = 1;
#[doc = " can call ebur128_loudness_shortterm"]
pub const mode_EBUR128_MODE_S: mode = 3;
#[doc = " can call ebur128_loudness_global_* and ebur128_relative_threshold"]
pub const mode_EBUR128_MODE_I: mode = 5;
#[doc = " can call ebur128_loudness_range"]
pub const mode_EBUR128_MODE_LRA: mode = 11;
#[doc = " can call ebur128_sample_peak"]
pub const mode_EBUR128_MODE_SAMPLE_PEAK: mode = 17;
#[doc = " can call ebur128_true_peak"]
pub const mode_EBUR128_MODE_TRUE_PEAK: mode = 49;
#[doc = " uses histogram algorithm to calculate loudness"]
pub const mode_EBUR128_MODE_HISTOGRAM: mode = 64;
#[doc = " \\enum mode"]
#[doc = "  Use these values in ebur128_init (or'ed). Try to use the lowest possible"]
#[doc = "  modes that suit your needs, as performance will be better."]
pub type mode = u32;
#[doc = " forward declaration of ebur128_state_internal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ebur128_state_internal {
    _unused: [u8; 0],
}
#[doc = " \\brief Contains information about the state of a loudness measurement."]
#[doc = ""]
#[doc = "  You should not need to modify this struct directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ebur128_state {
    #[doc = "< The current mode."]
    pub mode: ::std::os::raw::c_int,
    #[doc = "< The number of channels."]
    pub channels: ::std::os::raw::c_uint,
    #[doc = "< The sample rate."]
    pub samplerate: ::std::os::raw::c_ulong,
    #[doc = "< Internal state."]
    pub d: *mut ebur128_state_internal,
}
extern "C" {
    #[doc = " \\brief Get library version number. Do not pass null pointers here."]
    #[doc = ""]
    #[doc = "  @param major major version number of library"]
    #[doc = "  @param minor minor version number of library"]
    #[doc = "  @param patch patch version number of library"]
    pub fn ebur128_get_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Initialize library state."]
    #[doc = ""]
    #[doc = "  @param channels the number of channels."]
    #[doc = "  @param samplerate the sample rate."]
    #[doc = "  @param mode see the mode enum for possible values."]
    #[doc = "  @return an initialized library state, or NULL on error."]
    pub fn ebur128_init(
        channels: ::std::os::raw::c_uint,
        samplerate: ::std::os::raw::c_ulong,
        mode: ::std::os::raw::c_int,
    ) -> *mut ebur128_state;
}
extern "C" {
    #[doc = " \\brief Destroy library state."]
    #[doc = ""]
    #[doc = "  @param st pointer to a library state."]
    pub fn ebur128_destroy(st: *mut *mut ebur128_state);
}
extern "C" {
    #[doc = " \\brief Set channel type."]
    #[doc = ""]
    #[doc = "  The default is:"]
    #[doc = "  - 0 -> EBUR128_LEFT"]
    #[doc = "  - 1 -> EBUR128_RIGHT"]
    #[doc = "  - 2 -> EBUR128_CENTER"]
    #[doc = "  - 3 -> EBUR128_UNUSED"]
    #[doc = "  - 4 -> EBUR128_LEFT_SURROUND"]
    #[doc = "  - 5 -> EBUR128_RIGHT_SURROUND"]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param channel_number zero based channel index."]
    #[doc = "  @param value channel type from the \"channel\" enum."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_CHANNEL_INDEX if invalid channel index."]
    pub fn ebur128_set_channel(
        st: *mut ebur128_state,
        channel_number: ::std::os::raw::c_uint,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Change library parameters."]
    #[doc = ""]
    #[doc = "  Note that the channel map will be reset when setting a different number of"]
    #[doc = "  channels. The current unfinished block will be lost."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param channels new number of channels."]
    #[doc = "  @param samplerate new sample rate."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_NOMEM on memory allocation error. The state will be"]
    #[doc = "      invalid and must be destroyed."]
    #[doc = "    - EBUR128_ERROR_NO_CHANGE if channels and sample rate were not changed."]
    pub fn ebur128_change_parameters(
        st: *mut ebur128_state,
        channels: ::std::os::raw::c_uint,
        samplerate: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the maximum window duration."]
    #[doc = ""]
    #[doc = "  Set the maximum duration that will be used for ebur128_loudness_window()."]
    #[doc = "  Note that this destroys the current content of the audio buffer."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param window duration of the window in ms."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_NOMEM on memory allocation error. The state will be"]
    #[doc = "      invalid and must be destroyed."]
    #[doc = "    - EBUR128_ERROR_NO_CHANGE if window duration not changed."]
    pub fn ebur128_set_max_window(
        st: *mut ebur128_state,
        window: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the maximum history."]
    #[doc = ""]
    #[doc = "  Set the maximum history that will be stored for loudness integration."]
    #[doc = "  More history provides more accurate results, but requires more resources."]
    #[doc = ""]
    #[doc = "  Applies to ebur128_loudness_range() and ebur128_loudness_global() when"]
    #[doc = "  EBUR128_MODE_HISTOGRAM is not set."]
    #[doc = ""]
    #[doc = "  Default is ULONG_MAX (at least ~50 days)."]
    #[doc = "  Minimum is 3000ms for EBUR128_MODE_LRA and 400ms for EBUR128_MODE_M."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param history duration of history in ms."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_NO_CHANGE if history not changed."]
    pub fn ebur128_set_max_history(
        st: *mut ebur128_state,
        history: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add frames to be processed."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param src array of source frames. Channels must be interleaved."]
    #[doc = "  @param frames number of frames. Not number of samples!"]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_NOMEM on memory allocation error."]
    pub fn ebur128_add_frames_short(
        st: *mut ebur128_state,
        src: *const ::std::os::raw::c_short,
        frames: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief See \\ref ebur128_add_frames_short"]
    pub fn ebur128_add_frames_int(
        st: *mut ebur128_state,
        src: *const ::std::os::raw::c_int,
        frames: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief See \\ref ebur128_add_frames_short"]
    pub fn ebur128_add_frames_float(
        st: *mut ebur128_state,
        src: *const f32,
        frames: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief See \\ref ebur128_add_frames_short"]
    pub fn ebur128_add_frames_double(
        st: *mut ebur128_state,
        src: *const f64,
        frames: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get global integrated loudness in LUFS."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param out integrated loudness in LUFS. -HUGE_VAL if result is negative"]
    #[doc = "             infinity."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_I\" has not been set."]
    pub fn ebur128_loudness_global(st: *mut ebur128_state, out: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get global integrated loudness in LUFS across multiple instances."]
    #[doc = ""]
    #[doc = "  @param sts array of library states."]
    #[doc = "  @param size length of sts"]
    #[doc = "  @param out integrated loudness in LUFS. -HUGE_VAL if result is negative"]
    #[doc = "             infinity."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_I\" has not been set."]
    pub fn ebur128_loudness_global_multiple(
        sts: *mut *mut ebur128_state,
        size: usize,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get momentary loudness (last 400ms) in LUFS."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param out momentary loudness in LUFS. -HUGE_VAL if result is negative"]
    #[doc = "             infinity."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    pub fn ebur128_loudness_momentary(
        st: *mut ebur128_state,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get short-term loudness (last 3s) in LUFS."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param out short-term loudness in LUFS. -HUGE_VAL if result is negative"]
    #[doc = "             infinity."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_S\" has not been set."]
    pub fn ebur128_loudness_shortterm(
        st: *mut ebur128_state,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get loudness of the specified window in LUFS."]
    #[doc = ""]
    #[doc = "  window must not be larger than the current window set in st."]
    #[doc = "  The current window can be changed by calling ebur128_set_max_window()."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param window window in ms to calculate loudness."]
    #[doc = "  @param out loudness in LUFS. -HUGE_VAL if result is negative infinity."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if window larger than current window in st."]
    pub fn ebur128_loudness_window(
        st: *mut ebur128_state,
        window: ::std::os::raw::c_ulong,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get loudness range (LRA) of programme in LU."]
    #[doc = ""]
    #[doc = "  Calculates loudness range according to EBU 3342."]
    #[doc = ""]
    #[doc = "  @param st library state."]
    #[doc = "  @param out loudness range (LRA) in LU. Will not be changed in case of"]
    #[doc = "             error. EBUR128_ERROR_NOMEM or EBUR128_ERROR_INVALID_MODE will be"]
    #[doc = "             returned in this case."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_NOMEM in case of memory allocation error."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_LRA\" has not been set."]
    pub fn ebur128_loudness_range(st: *mut ebur128_state, out: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get loudness range (LRA) in LU across multiple instances."]
    #[doc = ""]
    #[doc = "  Calculates loudness range according to EBU 3342."]
    #[doc = ""]
    #[doc = "  @param sts array of library states."]
    #[doc = "  @param size length of sts"]
    #[doc = "  @param out loudness range (LRA) in LU. Will not be changed in case of"]
    #[doc = "             error. EBUR128_ERROR_NOMEM or EBUR128_ERROR_INVALID_MODE will be"]
    #[doc = "             returned in this case."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_NOMEM in case of memory allocation error."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_LRA\" has not been set."]
    pub fn ebur128_loudness_range_multiple(
        sts: *mut *mut ebur128_state,
        size: usize,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get maximum sample peak from all frames that have been processed."]
    #[doc = ""]
    #[doc = "  The equation to convert to dBFS is: 20 * log10(out)"]
    #[doc = ""]
    #[doc = "  @param st library state"]
    #[doc = "  @param channel_number channel to analyse"]
    #[doc = "  @param out maximum sample peak in float format (1.0 is 0 dBFS)"]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_SAMPLE_PEAK\" has not"]
    #[doc = "      been set."]
    #[doc = "    - EBUR128_ERROR_INVALID_CHANNEL_INDEX if invalid channel index."]
    pub fn ebur128_sample_peak(
        st: *mut ebur128_state,
        channel_number: ::std::os::raw::c_uint,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get maximum sample peak from the last call to add_frames()."]
    #[doc = ""]
    #[doc = "  The equation to convert to dBFS is: 20 * log10(out)"]
    #[doc = ""]
    #[doc = "  @param st library state"]
    #[doc = "  @param channel_number channel to analyse"]
    #[doc = "  @param out maximum sample peak in float format (1.0 is 0 dBFS)"]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_SAMPLE_PEAK\" has not"]
    #[doc = "      been set."]
    #[doc = "    - EBUR128_ERROR_INVALID_CHANNEL_INDEX if invalid channel index."]
    pub fn ebur128_prev_sample_peak(
        st: *mut ebur128_state,
        channel_number: ::std::os::raw::c_uint,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get maximum true peak from all frames that have been processed."]
    #[doc = ""]
    #[doc = "  Uses an implementation defined algorithm to calculate the true peak. Do not"]
    #[doc = "  try to compare resulting values across different versions of the library,"]
    #[doc = "  as the algorithm may change."]
    #[doc = ""]
    #[doc = "  The current implementation uses a custom polyphase FIR interpolator to"]
    #[doc = "  calculate true peak. Will oversample 4x for sample rates < 96000 Hz, 2x for"]
    #[doc = "  sample rates < 192000 Hz and leave the signal unchanged for 192000 Hz."]
    #[doc = ""]
    #[doc = "  The equation to convert to dBTP is: 20 * log10(out)"]
    #[doc = ""]
    #[doc = "  @param st library state"]
    #[doc = "  @param channel_number channel to analyse"]
    #[doc = "  @param out maximum true peak in float format (1.0 is 0 dBTP)"]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_TRUE_PEAK\" has not"]
    #[doc = "      been set."]
    #[doc = "    - EBUR128_ERROR_INVALID_CHANNEL_INDEX if invalid channel index."]
    pub fn ebur128_true_peak(
        st: *mut ebur128_state,
        channel_number: ::std::os::raw::c_uint,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get maximum true peak from the last call to add_frames()."]
    #[doc = ""]
    #[doc = "  Uses an implementation defined algorithm to calculate the true peak. Do not"]
    #[doc = "  try to compare resulting values across different versions of the library,"]
    #[doc = "  as the algorithm may change."]
    #[doc = ""]
    #[doc = "  The current implementation uses a custom polyphase FIR interpolator to"]
    #[doc = "  calculate true peak. Will oversample 4x for sample rates < 96000 Hz, 2x for"]
    #[doc = "  sample rates < 192000 Hz and leave the signal unchanged for 192000 Hz."]
    #[doc = ""]
    #[doc = "  The equation to convert to dBTP is: 20 * log10(out)"]
    #[doc = ""]
    #[doc = "  @param st library state"]
    #[doc = "  @param channel_number channel to analyse"]
    #[doc = "  @param out maximum true peak in float format (1.0 is 0 dBTP)"]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_TRUE_PEAK\" has not"]
    #[doc = "      been set."]
    #[doc = "    - EBUR128_ERROR_INVALID_CHANNEL_INDEX if invalid channel index."]
    pub fn ebur128_prev_true_peak(
        st: *mut ebur128_state,
        channel_number: ::std::os::raw::c_uint,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get relative threshold in LUFS."]
    #[doc = ""]
    #[doc = "  @param st library state"]
    #[doc = "  @param out relative threshold in LUFS."]
    #[doc = "  @return"]
    #[doc = "    - EBUR128_SUCCESS on success."]
    #[doc = "    - EBUR128_ERROR_INVALID_MODE if mode \"EBUR128_MODE_I\" has not"]
    #[doc = "      been set."]
    pub fn ebur128_relative_threshold(
        st: *mut ebur128_state,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
